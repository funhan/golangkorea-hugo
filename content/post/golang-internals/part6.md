+++

title = "Golang의 내부, 6부: 부트스트래핑과 메모리 할당자"
draft = true
date = "2016-09-20T16:20:29-04:00"

tags = ["Golang", "Internals", "runtime", "bootstrap", "memory", "allocator"]
categories = ["번역", "핵킹"]
series = ["Golang  Internals"]
authors = ["Jhonghee Park"]

toc = true

+++

이 포스트는 Golang 내부 시리즈의 연속이다. Go 런타임을 자세히 이해하는데 열쇠와 같은 부트스트랩 과정을 살펴볼 것이다. 이번에는 시작하는 순서의 두번째 부분을 섭렵해서 어떻게 인수들이 초기화되고, 어떤 함수들이 호출되는지 등을 배우겠다.

# 시작하는 순서

지난 번에 얘기하다가 만 *runtime.rt0_go* 함수를 다시 다루어야 겠다. 아직 이 함수에서 살펴보지 않은 부분이 여전히 있다.

>```
01 CLD                         // convention is D is always left cleared
02 CALL    runtime·check(SB)
03
04 MOVL    16(SP), AX          // copy argc
05 MOVL    AX, 0(SP)
06 MOVQ    24(SP), AX          // copy argv
07 MOVQ    AX, 8(SP)
08 CALL    runtime·args(SB)
09 CALL    runtime·osinit(SB)
10 CALL    runtime·schedinit(SB)
```

첫번째 명령 (CLD)는 *FLAGS* 레지스터의 [direction](https://en.wikipedia.org/wiki/Direction_flag) 프래그를 지운다. 이 플래그는 문자열 처리 방향에 영향을 준다.

다음 함수는 *runtime.check* 함수를 호출하는데, 그 또한 이 문서의 목적에 비추어 그리 중요하지는 않다. 런타임은 모든 내장 타입의 인스턴스들을 만들고, 타입의 크기와 파라미터들을 확인하는 정도의 일을 한다. 그리고 만약 작업중 문제가 생기면 *panic* 한다. [function](https://github.com/golang/go/blob/go1.5.1/src/runtime/runtime1.go#L136)를 통해 쉽게 알아볼 수 있다.

# 인수 분석하기

그 다음 함수 [runtime.Args](https://github.com/golang/go/blob/go1.5.1/src/runtime/runtime1.go#L48) 는 좀 더 흥미롭다. The next function, 리눅스 시스템에서 (*argc* 와 *argv*) 인수를 정적 변수속에 저장하는 것말고도 이 함수는 ELF 보조 벡터를 분석하며 *syscall* 주소를 초기화한다.

설명이 좀 더 필요하겠다. 운영체계가 프로그램을 메모리에 올릴때, 그 프로그램의 초기 스택을 미리 정해진 포맷의 어떤 데이타로 초기화한다. 스택의 꼭대기에는 환경 변수들의 포인터인 인수들이 깔린다. 스택의 바닥에는 "ELF 보조 벡터"를 볼 수 인데, 실제로 이 것은 어떤 유용한 정보를 담고 있는 기록의 배열들이다. 예를 들면, 프로그램 헤더의 수와 크기들이다. 여기 이 [문서](http://articles.manugarg.com/aboutelfauxiliaryvectors)를 통해 ELF 보조 벡터 포맷에 대해 좀 자세히 알아 보라.

*runtime.Args* 함수는 벡터를 파싱하는 책임이 있다. 런타임은 벡터에 담고 있는 모든 정보들 중에 단지 *startupRandomData* 만을 사용하는데, 주로 헤싱 함수(hashing functions)들과 어떤 syscall들의 위치를 가리키는 포인터들을 초기화하는데 주로 사용된다. 다음에 나오는 변수들을 초기화한다:

>```
1 __vdso_time_sym
2 __vdso_gettimeofday_sym
3 __vdso_clock_gettime_sym
```

이 것들은 여러 함수들내 현재 시간을 획득하는데 사용된다. 이 모든 변수들은 기본값을 가진다. 이렇게 함으로써 Golang에서 상응하는 함수들을 호출하기 위해 *[vsyscall](http://www.ukuug.org/events/linux2001/papers/html/AArcangeli-vsyscalls.html)* 메카니즘의 사용이 허용된다.

# *runtime.osinit* 함수의 내부

시작 순서에서 그 다음으로 호출되는 함수는 *[runtime.osinit](https://github.com/golang/go/blob/go1.5.1/src/runtime/os1_linux.go#L172)* 이다. 리눅스 시스템에서 단 한가지 하는 일이 있는데 그것은 시스템내 CPU 숫자를 가지고 있는 ncpu 변수를 한 syscall을 통해 초기화하는 것이다.

# *runtime.schedinit* 함수의 내부

시작 순서에서 다음 함수인 *[runtime.schedinit](https://github.com/golang/go/blob/go1.5.1/src/runtime/proc1.go#L40)* 는 더 흥미롭다. 현재의 고루틴을 얻는 것으로 시작하는데, 사실 이 것은 *[g](https://github.com/golang/go/blob/go1.5.1/src/runtime/runtime2.go#L211)* 구조의 포인터이다. 이미 이 포인터가 어떻게 저장되는 지는 TLS 구현을 논할 때 얘기한 바있다. 다음은 *[runtime.raceinit](https://github.com/golang/go/blob/go1.5.1/src/runtime/race1.go#L110)* 를 호출한다. runtime.raceinit에 대한 토론은 넘어가겠다. 왜냐하면 이 함수는 race 조건이 활성화되지 않은 경우는 보통 호출되지 않기 때문이다. 그 다음에는 몇몇 다른 초기화 함수들이 호출된다.

하나씩 살펴보자.


# Initializing traceback

The *[runtime.tracebackinit](https://github.com/golang/go/blob/go1.5.1/src/runtime/traceback.go#L58)* function is responsible for initializing traceback. Traceback is a stack of functions that were called before we got to the current point of execution. For example, we can see it each time a panic occurs. Traceback is generated by a given program counter by calling a function called *[runtime.gentraceback](https://github.com/golang/go/blob/go1.5.1/src/runtime/traceback.go#L120)*. For this function to work, we need to know the addresses of some built-in functions (e.g., because we don’t want them to be included into the traceback). *runtime.tracebackinit* is responsible for initializing these addresses.



# Verifying linker symbols

Linker symbols are data emitted by the linker to the executable and the object file. Most of these symbols’ contents have been discussed in [Golang Internals, Part 3: The Linker, Object Files, and Relocations](http://blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html). In the runtime package, linker symbols are mapped to the *[moduledata](https://github.com/golang/go/blob/go1.5.1/src/runtime/symtab.go#L37)* struct. The *[runtime.moduledataverify](https://github.com/golang/go/blob/go1.5.1/src/runtime/symtab.go#L95)* function is responsible for performing some checks against this data and verifying that it has the correct structure and is not corrupted.



# Initializing the stack pool

To understand the next initialization step, you need a bit of knowledge about how stack growth is implemented in Go. When a new goroutine is created, a small fixed-size stack is allocated for it. When the stack reaches some threshold, its size is doubled and the stack is copied to another location.

There is still a lot of detail on how reaching this threshold is determined and how Go adjusts pointers in the stack. I have already touched on some of these things in my previous blog posts, when talking about the *stackguard0* field and function metadata. You can also find a lot of useful information on this subject in [this document](https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub).

Go uses a stack pool to cache currently unused stacks. The stack pool is an array initialized in the *[runtime.stackinit](https://github.com/golang/go/blob/go1.5.1/src/runtime/stack1.go#L54)* function. Each item in this array contains a linked list of stacks of the same size.

Another variable initialized at this stage is *runtime.stackFreeQueue*. It also contains a linked list of stacks, but these are added to the list during garbage collection and are cleared after it is finished. Note that only 2 KB, 4 KB, 8 KB, and 16 KB stacks are cached. Larger ones are allocated directly.



# Initializing the memory allocator

The process of memory allocation is described in this [source code comment](https://github.com/golang/go/blob/go1.5.1/src/runtime/malloc.go#L5). I strongly encourage you to read it, if you want to understand how memory allocation works. This topic will be covered in more detail in one of the upcoming posts. Initialization of the memory allocator is located in the *[runtime.mallocinit](https://github.com/golang/go/blob/go1.5.1/src/runtime/malloc.go#L216)* function, so let’s take a closer look at it.



# Initializing size classes

The first thing we can see here is that *runtime.mallocinit* is calling another function—*[initSizes](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L66)*, which is responsible for calculating size classes. But what size does a class have? When allocating a small object (less than 32 KB), the Go runtime first rounds its size up to a pre-defined class size. So the allocated block of memory can only have one of the predefined sizes that is usually larger than what is required for the object itself. This leads to a small memory wastage, but it enables you to easily re-use allocated memory blocks for different objects.

The *initSizes* function is responsible for calculating these classes. At the top of this function, we can see the following code:

>```
01     align := 8
02     for size := align; size <= _MaxSmallSize; size += align {
03         if size&(size-1) == 0 {
04             if size >= 2048 {
05                 align = 256
06             } else if size >= 128 {
07                 align = size / 8
08             } else if size >= 16 {
09                 align = 16
10 …
11             }
12         }
```

As we can see, the smallest two size classes are 8 and 16 bytes. Subsequent classes are located in every 16 bytes up to 128 bytes. From 128 to 2,048 bytes, classes are located in every size/8 bytes. After 2,048 bytes, size classes are located in every 256 bytes.

The *initSizes* method initializes the *[class_to_size](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L49)* array, which converts a class (here, by class we mean its index in the class list) to its size. It also initializes the *[class_to_allocnpages](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L50)* array that stores data on how many memory pages should be obtained from the OS to fill one object of a given class, and two more arrays—*[size_to_class8](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L53)* and *[size_to_class128](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L54)*. These serve for conversion from object size to a corresponding class index. The first one converts object sizes smaller than 1 KB, and the second one is for object sizes of 1–32 KB.



# Virtual memory reservation

The next thing the *mallocinit* function does is reserve virtual memory for future allocations. Let’s see how this is done on x64 architectures. First of all, we need to initialize the following variables:

>```
1 arenaSize := round(_MaxMem, _PageSize)
2 bitmapSize = arenaSize / (ptrSize * 8 / 4)
3 spansSize = arenaSize / _PageSize * ptrSize
4 spansSize = round(spansSize, _PageSize)
```

 * *arenaSize* is the maximum amount of virtual memory that can be reserved for object allocations. On 64-bit architectures, it is equal to 512 GB.
 * *bitmapSize* corresponds to the amount of memory reserved for the garbage collector (GC) bitmap. The GC bitmap is a special memory type used to show where exactly pointers are located in memory and whether the object, which is pointed to, is marked by GC.
 * *spansSize* is the amount of memory reserved for storing an array of pointers to all memory spans. A memory span is a structure that wraps a block of memory used for object allocations.

Once all these variables have been calculated, the actual reservation is done:

>```
1 pSize = bitmapSize + spansSize + arenaSize + _PageSize
2 p = uintptr(sysReserve(unsafe.Pointer(p), pSize, &reserved))
```

Finally, we can initialize the *[mheap](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L65)* global variable that is used as central storage for all memory-related objects.

>```
1 p1 := round(p, _PageSize)
2
3 mheap_.spans = (**mspan)(unsafe.Pointer(p1))
4 mheap_.bitmap = p1 + spansSize
5 mheap_.arena_start = p1 + (spansSize + bitmapSize)
6 mheap_.arena_used = mheap_.arena_start
7 mheap_.arena_end = p + pSize
8 mheap_.arena_reserved = reserved
```

Note that, from the beginning, *mheap_.arena_used* is initialized with the same address as *mheap_.arena_start*, because nothing has been allocated yet.



# Initializing the heap

Next, the *[mHeap_Init](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L273)* function is called. The first thing that is done here is allocator initialization.

>```
1 fixAlloc_Init(&h.spanalloc, unsafe.Sizeof(mspan{}), recordspan, unsafe.Pointer(h), &memstats.mspan_sys)
2 fixAlloc_Init(&h.cachealloc, unsafe.Sizeof(mcache{}), nil, nil, &memstats.mcache_sys)
3 fixAlloc_Init(&h.specialfinalizeralloc, unsafe.Sizeof(specialfinalizer{}), nil, nil, &memstats.other_sys)
4 fixAlloc_Init(&h.specialprofilealloc, unsafe.Sizeof(specialprofile{}), nil, nil, &memstats.other_sys)
```

To better understand what an allocator is, let’s see how it is utilized. All allocators operate in the *[fixAlloc_Alloc](https://github.com/golang/go/blob/go1.5.1/src/runtime/mfixalloc.go#L54)* function, called each time we want to allocate new *[mspan](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L101)*, *[mcache](https://github.com/golang/go/blob/go1.5.1/src/runtime/mcache.go#L11)*, *[specialfinalizer](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L1009)*, and *[specialprofile](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L1050)* structs. The main part of this function is:

>```
1 if uintptr(f.nchunk) < f.size {
2     f.chunk = (*uint8)(persistentalloc(_FixAllocChunk, 0, f.stat))
3     f.nchunk = _FixAllocChunk
4 }
```

It allocates memory, but instead of allocating the actual size of the structure—*f.size* bytes—we set aside *[_FixAllocChunk](https://github.com/golang/go/blob/go1.5.1/src/runtime/malloc.go#L130)* bytes (currently equal to 16 KB). The rest of the available space is stored in the allocator. Next time we need to allocate a structure of the same type, it will not require calling [persistentalloc](https://github.com/golang/go/blob/go1.5.1/src/runtime/malloc.go#L828), which can be time consuming.

The *persistentalloc* function is responsible for allocating memory that should not be garbage collected. Its workflow is as follows:

 1. If the allocated block is larger than 64 KB, it is allocated directly from OS memory
 2. Otherwise, we first need to find a persistent allocator:
    * A persistent allocator is attached to each processor. This is done to avoid using locks when working with a persistent allocator. So, we try to use a persistent allocator from the current processor.
    * If we cannot obtain information about the current processor, a global system allocator is used.
 3. If the allocator does not have enough free memory in its cache, we set aside more memory from the OS.
 4. The required amount of memory is returned from the allocator’s cache

The *persistentalloc* and *fixAlloc_Alloc* functions work in similar ways. It is possible to say that those functions implement two levels of caching. You should also be aware that *persistentalloc* is used not only in *fixAlloc_Alloc*, but also in many other places where we need to allocate persistent memory.

Let’s return to the *mHeap_Init* function. One more important question to answer here is how the four structures, for which allocators were initialized at the beginning of this function, are used:

 * *mspan* is a wrapper for a memory block that should be garbage collected. We have talked about it when discussing size classes. A new mspan is created when we need to allocate a new object of a particular size class.
 * *mcache* is a struct attached to each processor. It is responsible for caching spans. The reason for having a separate cache for each processor is to avoid locking.
 * *specialfinalizeralloc* is a struct that is allocated when the *runtime.SetFinalizer* function is called. This can be done if we want the system to execute some cleanup code when an object is cleared. A good example is the *os.NewFile* function that associates a finalizer with each new file. This finalizer should close the OS file descriptor.
 * *specialprofilealloc* is a struct employed in the memory profiler.

After initializing memory allocators, the *mHeap_Init* function initializes lists by calling *[mSpanList_Init](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L863)*, which is very simple. All it does is initialize the first entry for the linked list. The *mheap* struct contains a few such linked lists.

 * *mheap.free* and *mheap.busy* are arrays that contain *free* and *busy* lists with spans for large objects (larger than 32 KB, but smaller than 1 MB). Each of these arrays contains one item per each possible size. Here, sizes are measured in pages. One page is equal to 32 KB. The first item contains a list with 32 KB spans, the second one contains a list with 64 KB spans, and so on.
 * *mheap.freelarge* and *mheap.busylarge* are free and busy lists for objects larger than 1 MB

The next step is to initialize *mheap.central*, which stores spans for small objects (less than 32 KB). In *mheap.central*, lists are grouped accordingly to their size classes. Initialization is very similar to what we have seen previously. It is simply initialization of linked lists for each free list.



# Initializing the cache

Now, we are almost done with memory allocator initialization. The last thing that is left in the *mallocinit* function is mcache initialization:

>```
1 _g_ := getg()
2 _g_.m.mcache = allocmcache()
```

Here, we first obtain the current coroutine. Each goroutine contains a link to the *m* struct. This struct is a wrapper around the operating system thread. Inside this struct, there is a field called *mcache* that is initialized in these lines. The *allocmcache* function calls *fixAlloc_Alloc* to initialize a new *mcache* struct. We have already discussed how allocation is done and the meaning of this struct (see above).

A careful reader may notice that I have previously said *mcache* is attached to each processor, but now we see that it is attached to the *m* struct, which corresponds to an OS process, not a processor. And that is correct—mcache is initialized only for those threads that are currently executed and it is re-located to another thread whenever a process switch occurs.



# More about Go bootstrapping soon

In the next post, we will continue discussing the bootstrap process by looking at how the garbage collector is initialized and how the main goroutine is started. Meanwhile, don’t hesitate to share your thoughts and suggestions in the comments below.

* 원문: [Golang Internals, Part 6: Bootstrapping and Memory Allocator Initialization](http://blog.altoros.com/golang-internals-part-6-bootstrapping-and-memory-allocator-initialization.html)
* 저자: Siarhei Matsiukevich
* 번역자: Jhonghee Park
